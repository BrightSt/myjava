# <center>java并发编程</center>

### 1.请谈谈你对volatile的理解

#### volatile是java虚拟机提供的轻量级的同步机制

* 保证可见性
* 禁止指令重排序
* 不保证原子性

#### JMM(java内存模型)你谈谈

**基本概念**

* JMM本身是一种抽象的概念并不是真实存在的，它描述的是一组规定或者规范，通过这组规范定义了程序中的访问方式
* JMM 同步规定
  * 线程解锁前，必须把共享变量的值刷新回主内存
  * 线程加锁前，必须读取主内存的最新值到自己的工作内存
  * 加锁解锁是同一把锁

* 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作(读取赋值等）必须都在工作内存进行。
* 首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
* 内存模型图

![](JMM内存模型.png)

#### 三大特性

* 可见性

```java
package com.dms.java.concurrency;

/**
 * volatile 可见性代码示例:
 * 如果a不加volatile，线程之间是不可见的。
 * 步骤为：首先在主内存里创建了data变量，Thread-0拷贝一份到自己的工作内存里，
 * 修改了a的值，但是什么时候把数据刷回到主内存是不确定的，即使刷回到主内存在main线程也是不可见的，
 * 因为main线程与Thread-0线程一样会从主内存里拷贝一份至工作内存，所以无论Thread-0如何修改
 * main工作内存里的a始终是0，所以main线程会一致循环，不会走到 “job is done”
 * 
 * 如果加了valatile，表示不同线程间对a都是可见的，Thread-0修改了，
 * 在main线程也能同步看到，所以main线程读取的a为1了，所以可以走到“job is done”
 * @author Dong
 *
 */
public class VolatileVisibleDemo {
	
	public static void main(String[] args) {
		Data data = new Data();
		new Thread(()->{
			System.out.println(Thread.currentThread().getName() + "coming ...");
			try {
				Thread.sleep(3000);
			} catch (Exception e) {
				e.printStackTrace();
			}
			data.addOne();
			System.out.println(Thread.currentThread().getName()+"updated...");
		}).start(); 
		
		while(data.a == 0 ) {
			
		}
		System.out.println(Thread.currentThread().getName() + "job is done");
	}
}

class Data{
	//int a = 0;
	volatile int a = 0;
	void addOne() {
		this.a += 1;
	}
}

```

* 原子性

```java
package com.dms.java.concurrency;

/**
 * volatile 原子性测试示例
 * 不保证原子性
 * @author Dong
 *
 */
public class VolatileAtomDemo {
	
	public static void main(String[] args) {
		test();
	}
	
	private static void test() {
		Data data = new Data();
		
		for(int i=0;i<20;i++) {
			new Thread(()->{
				for(int j =0;j<1000;j++) {
					data.addOne();
				}
			}).start();  
		}
		
//		try {
//			Thread.sleep(5000);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
		
		 // 默认有 main 线程和 gc 线程
        while (Thread.activeCount() > 2) {
            Thread.yield();
        }
		System.out.println(data.a);
	}
}

//class Data{
//	
//	volatile int a = 0;
//	
//	void addOne() {
//		this.a += 1;
//	}
//	
//}
```

* 有序性

  * 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下3种
    * 编译器优化的重排
    * 指令并行的重排
    * 内存系统的重排

  * 单线程环境里面确保程序最终执行的结果和代码执行的结果一致
  * 处理器在进行重排序时必须考虑指令之间的数据依赖性
  * 多线程环境中线程交替执行，由于编译器优化重排的存在，连个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
  * 代码示例

  ```java
  package com.dms.java.concurrency;
  
  /**
   * 指令重排序的例子
   * 如果两个线程同时执行，method01 和 method02 如果线程 1 执行 method01 重排序了，
   * 然后切换的线程 2 执行 method02 就会出现不一样的结果。
   * @author Dong
   *
   */
  public class ReSortSeqDemo {
  	
  	int a = 0;
  	boolean flag = false;
  	
  	public void method1() {
  		a=1;
  		flag = true;
  	}
  	
  	public void method2() {
  		if(flag) {
  			a = a+3;
  			System.out.println("a= "+a);
  		}
  	}
  	
  	public static void main(String[] args) {
  		ReSortSeqDemo demo = new ReSortSeqDemo();
  		
  		new Thread(()->{
  			demo.method1();
  		}).start();
  		
  		new Thread(()->{
  			demo.method2();
  		}).start();; 
  	}
  
  }
  
  ```

  

#### 禁止指令排序

volatile实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象。

先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，他的作用有两个：

* 保证特定操作的执行顺序
* 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）

由于编译器和处理器都能执行指令重排序优化，如果在指令间插入一条Memory Barrier，则会告诉编译器和CPU，不管什么指令都不能对这个条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种CPU缓存数据，因此任务CPU上的线程都能读取到这些数据的最新版本。

下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：

![](volatile指令序列示意图.png)

下面是保守策略下，volatile读插入内存屏障后生成的指令序列示意图：

![](volatile读.png)



#### 线程安全性保证

* 工作内存与主内存同步延迟现象导致可见性问题
  * 可以使用synchronzied或volatile关键字解决，他们可以使用一个线程修改后的变量立即对其他线程可见

* 对于指令重排导致可见性问题和有序问题
  * 可以利用volatile关键字解决，因为volatile的另一个作用就是禁止指令重排序优化

#### 你在哪些地方用到过valatile

##### 单例

* 多线程环境下可能存在的安全问题

```java
package com.dms.java.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 这个在多线程下达不到单例的效果，多次运行会存在构造函数被调用多次的情况。
 * 发现构造器里的内容会多次输出
 * @author Dong
 *
 */
public class VolatileUseSingleton01 {

	private static VolatileUseSingleton01 instance = null;
	
	private VolatileUseSingleton01() {
		System.out.println(Thread.currentThread().getName() + " construction ....");
	}
	
	public static VolatileUseSingleton01 getInstance() {
		if(instance == null) {
			instance = new VolatileUseSingleton01();
		}
		
		return instance;
	}
	
	public static void main(String[] args) {
		ExecutorService executorService = Executors.newFixedThreadPool(10);
		
		for (int i = 0;i<10;i++) {
			executorService.execute(()->VolatileUseSingleton01.getInstance());
		}
		
		executorService.shutdown();
	}
}

```

* 双重锁单例
  * 代码

```java
package com.dms.java.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
/**
 * 双重锁单例
 * instance加volatile的必要性：
 * @author Dong
 *
 */
public class VolatileUseSingleton02 {
	
	private static volatile VolatileUseSingleton02 instance = null;
	
	private VolatileUseSingleton02() {
		System.out.println(Thread.currentThread().getName() + " construction...");
	}
	
	public static VolatileUseSingleton02 getInstance() {
		if(instance == null ) {
			synchronized (VolatileUseSingleton02.class) {
				if(instance == null) {
					instance = new VolatileUseSingleton02();
				}
			}
		}
		
		return instance;
	}

	
	public static void main(String[] args) {
		ExecutorService executorService = Executors.newFixedThreadPool(10);
		for(int i=0;i<10;i++) {
			executorService.execute(()->VolatileUseSingleton02.getInstance());
		}
		executorService.shutdown();
	}
}

```

* 如果没有加volatile就不一定是线程安全的，原因是指令重排序的存在，加入volatile可以禁止指令重排序。

* 原因是在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能还没有完成初始化。

* instance = new VolatileUseSingleton02() 可以分为以下三步完成

  > memory = allocate(); // 1.分配对象空间
  >
  > instance（memory）； // 2.初始化对象
  >
  > instance = memory; // 3.设置instance指向刚分配的内存地址，此时instance！=null

* 步骤2和步骤3不存在依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种优化是允许的。

* 发生重排

  > memory = allocate(); // 1.分配对象空间
  >
  > instance = memory; // 3.设置instance指向刚分配的内存地址，此时instance！=null,但对象还没有初始化完成
  >
  > instance(memory)；//  2.初始化对象

* 所以不加volatile返回的示例不为空，但可能是未初始化的示例。

### 2.CAS你知道吗

* 一个CAS的简单示例：

```java
package com.dms.java.concurrency;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * CAS使用示例  CAS=compare and swap 比较并交换
 * 先比较，比较的内容为：期望值与实际值是否一样，如果一样就交换新值。如果不一样就无法交换，返回false
 * AtomicXX 就是使用了CAS
 * @author Dong
 *
 */
public class CASDemo {

	public static void main(String[] args) {
		AtomicInteger atomicInteger = new AtomicInteger(666);
		boolean b = atomicInteger.compareAndSet(666, 2019);
		System.out.println(b +" atomicInteger value = " + atomicInteger.get());
		
		boolean b1 = atomicInteger.compareAndSet(666, 2020);
		System.out.println(b1 +" atomicInteger value = " + atomicInteger.get());
		
		atomicInteger.getAndIncrement();

	}

}
```

#### CAS底层原理？谈谈对UNSafe的理解？

##### 源码分析 atomicInteger.getAndIncrement();

```java
    /**
     * Atomically increments by one the current value.
     *
     * @return the previous value
     */
    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
```

##### UnSafe 类

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    // ...
}
```

* UnSafe是CAS的核心类，由于Java方法无法直接访问底层系统，而需要通过本地（native）方法来访问，UnSafe类相当一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C指针一样直接操作内存，因为Java中CAS操作执行依赖于Unsafe类。
* 变量valueOffset，表示该变量值在内存中的偏移量，因为Unsafe就是根据内存偏移量来获取数据的。
* 变量value用volatile修饰，保证了多线程之间的内存可见性。

##### CAS是什么

* CAS的全称Compare-And-Swap，它是一条CPU并发原语
* 它的功能是判断内存某一个位置的值是否为预期，如果是则更改这个值，这个过程就是原子的。
* CAS并发原子体现在Java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮助我们实现出CAS汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成，用语完成某一个功能的过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说CAS是一条原子指令，不会造成所谓的数据不一致的问题。

* 分析一下getAndAddInt这个方法

```java
  public final int getAndAddInt(Object paramObject, long paramLong, int paramInt)
  {
    int i;
    do
    {
      i = getIntVolatile(paramObject, paramLong);
    } while (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));
    return i;
  }
```

